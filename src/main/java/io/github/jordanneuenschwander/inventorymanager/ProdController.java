package io.github.jordanneuenschwander.inventorymanager;

import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.stage.Stage;

import java.util.Optional;

/**
 * This class handles all logic involved with the execution of the product view
 *
 * @author Jordan Neuenschwander
 * @version 1.0
 */
public class ProdController {

    /**
     * A stored copy of the current state of the <code>Inventory</code> model
     */
    private static Inventory inventory;
    /**
     * A flag used to determine if the product view is in add or modify mode
     */
    private static boolean isModify = false;

    /**
     * An autogenerated unique integer value used for initializing the id of new <code>Product</code> objects
     */
    private static int nextProductId = 0;

    /**
     * The index of the product being modified
     */
    private static int modProductIndex;
    private static  ObservableList<Part> holderAssociatedParts;

    /**
     * The text box that is used for user input search strings
     */
    @FXML
    private TextField textPartSearchProd;

    /**
     * The table that displays the all parts table from the stored <code>Inventory</code>
     */
    @FXML
    private TableView<Part> tablePartsProd;

    /**
     * Table column for the part id
     */
    @FXML
    private TableColumn<Part, Number> columnPartIdProd;

    /**
     * Table column for the part name
     */
    @FXML
    private TableColumn<Part, String> columnPartNameProd;

    /**
     * Table column for the part stock
     */
    @FXML
    private TableColumn<Part, Number> columnPartStockProd;

    /**
     * Table column for the cost per unit of the part
     */
    @FXML
    private TableColumn<Part, Number> columnPartCPIProd;

    /**
     * Table that displays the <code>associatedParts</code> list from the current product
     */
    @FXML
    private TableView<Part> tableAssociatedProd;

    /**
     * Table column for the id of the associated part
     */
    @FXML
    private TableColumn<Part, Number> columnAssociatedId;

    /**
     * Table column for the name of the associated part
     */
    @FXML
    private TableColumn<Part, String> columnAssociatedName;

    /**
     * Table column for the stock of the associated part
     */
    @FXML
    private TableColumn<Part, Number> columnAssociatedStock;

    /**
     * Table column for the cost per unit of the associated part
     */
    @FXML
    private TableColumn<Part, Number> columnAssociatedCPI;

    /**
     * Text box used for user input of the product ID
     */
    @FXML
    private TextField textProdId;

    /**
     * Text box used for user input of the product name
     */
    @FXML
    private TextField textProdName;

    /**
     * Text box used for user input of the product stock
     */
    @FXML
    private TextField textProdStock;

    /**
     * Text box used for user input of the product cost per unit
     */
    @FXML
    private TextField textProdCPI;

    /**
     * Text box used for user input of the product minimum stock
     */
    @FXML
    private TextField textProdMin;

    /**
     * Text box used for user input of the product maximum stock
     */
    @FXML
    private TextField textProdMax;

    /**
     * Label that serves as a header. Changed depending on modify or add product view
     */
    @FXML
    private Label labelAddProd;

    /**
     * This method initializes the list of associated parts to empty and binds the table columns to the data they will be displaying.
     */
    @FXML
    private void initialize(){
        textPartSearchProd.textProperty().addListener( (observable, oldValue, newValue) ->
                partSearch()
        );

        holderAssociatedParts = FXCollections.observableArrayList();

        tablePartsProd.isEditable();
        columnPartIdProd.setCellValueFactory(cellData -> new SimpleIntegerProperty(cellData.getValue().getId()));
        columnPartNameProd.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getName()));
        columnPartStockProd.setCellValueFactory(cellData -> new SimpleIntegerProperty(cellData.getValue().getStock()));
        columnPartCPIProd.setCellValueFactory(cellData -> new SimpleDoubleProperty(cellData.getValue().getPrice()));

        tableAssociatedProd.isEditable();
        columnAssociatedId.setCellValueFactory(cellData -> new SimpleIntegerProperty(cellData.getValue().getId()));
        columnAssociatedName.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getName()));
        columnAssociatedStock.setCellValueFactory(cellData -> new SimpleIntegerProperty(cellData.getValue().getStock()));
        columnAssociatedCPI.setCellValueFactory(cellData -> new SimpleDoubleProperty(cellData.getValue().getPrice()));
    }

    /**
     * Refreshes the data presented in the tables
     */
    private void refreshTables(){
        tablePartsProd.getItems().setAll(inventory.getAllParts());
        tableAssociatedProd.getItems().setAll(holderAssociatedParts);
    }

    /**
     * Clears the product view of all input and sets the view to its default state
     */
    private void clearPage(){
        textProdId.clear();
        textProdName.clear();
        textProdStock.clear();
        textProdMin.clear();
        textProdMax.clear();
        textProdCPI.clear();
        labelAddProd.setText("Add Product");
    }

    /**
     * This method sets up the view to be in the state where it has the add product functionality
     * It sets a flag so the controller knows which mode the view is in and creates a copy of the <code>Inventory</code>
     * model used by the <code>MainController</code>
     *
     * @param newInventory the <code>Inventory</code> to be copied into member variable inventory
     */
    public void addView(Inventory newInventory){
        isModify = false;
        inventory = newInventory;

        labelAddProd.setText("Add Product");
        textProdId.setText(""+ nextProductId);

        tablePartsProd.getItems().setAll(inventory.getAllParts());
        tableAssociatedProd.getItems().setAll(holderAssociatedParts);
    }

    /**
     * This method sets up the view to be in a "modify product" state.
     * It prints the data stored in a <code>Product</code> object to the relevant text boxes and initializes the associated parts table
     * with the <code>associatedParts</code> list from the product
     * Sets a flag so the controller knows what mode the view is in.
     *
     * @param index the index where the <code>modifyProduct</code> is located
     * @param modifyProduct the product to be modified
     * @param newInventory the current inventory
     */
    public void modifyView(int index, Product modifyProduct, Inventory newInventory) {
        inventory = newInventory;
        isModify = true;
        modProductIndex = index;
        holderAssociatedParts = modifyProduct.getAllAssociatedParts();

        labelAddProd.setText("Modify Product");
        textProdId.setText(Integer.toString(nextProductId));
        textProdId.setText(Integer.toString(modifyProduct.getId()));
        textProdName.setText(modifyProduct.getName());
        textProdStock.setText("" + modifyProduct.getStock());
        textProdCPI.setText("" + modifyProduct.getPrice());
        textProdMin.setText("" + modifyProduct.getMin());
        textProdMax.setText("" + modifyProduct.getMax());

        tablePartsProd.getItems().setAll(inventory.getAllParts());
        tableAssociatedProd.getItems().setAll(holderAssociatedParts);
    }

    /**
     * Asks the user if they would like to return to the MainView and goes to the main view upon confirmation
     *
     * @param event the event thrown when the cancel button is clicked
     *
     * @throws Exception NullPointerException when the <code>FXMLLoader</code> can not find the fxml file
     * @throws Exception IOException if FXMLLoader attempts to load a null value
     */
    @FXML
    void onClickCancel(ActionEvent event) throws Exception{
        Alert a = new Alert(Alert.AlertType.CONFIRMATION);
        a.setTitle("Cancel Confirmation");
        a.setContentText("Are you sure you want to cancel?");

        Optional<ButtonType> result = a.showAndWait();
        if (result.isPresent() && (result.get() == ButtonType.OK)) {
            clearPage();
            FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("MainView.fxml"));
            Node node = (Node) event.getSource();
            Stage stage = (Stage) node.getScene().getWindow();
            stage.setScene(new Scene(fxmlLoader.load(), 1055, 364));
        }
    }

    /**
     * This method adds the part that is selected in the parts table to the associated parts table
     *
     * @param event event thrown when the add button under the parts table is clicked
     */
    @FXML
    void onClickPartAdd(ActionEvent event){
        Part selected = tablePartsProd.getSelectionModel().getSelectedItem();
        if (selected == null) {
            Alert a = new Alert(Alert.AlertType.ERROR);
            a.setTitle("Error - No Part Selected");
            a.setContentText("You have not selected a part to add to the associated parts table.");
            a.show();
        } else {
            Alert a = new Alert(Alert.AlertType.CONFIRMATION);
            a.setTitle("Add Confirmation");
            a.setContentText("Are you sure you want to add " + selected.getName() +" to the associated parts table?");

            Optional<ButtonType> result = a.showAndWait();
            if (result.isPresent() && (result.get() == ButtonType.OK)) {
                holderAssociatedParts.add(selected);
                tablePartsProd.getSelectionModel().clearSelection();
                tableAssociatedProd.getItems().setAll(holderAssociatedParts);
            }
        }
    }

    /**
     * This method removes the currently selected associated part from the associated parts table
     *
     * @param event event thrown when the removed associated parts button is clicked
     */
    @FXML
    void onClickRemoveAssociated(ActionEvent event) {
        Part selected = tableAssociatedProd.getSelectionModel().getSelectedItem();
        if (selected == null){
            Alert a = new Alert(Alert.AlertType.ERROR);
            a.setTitle("Error - No Part Selected");
            a.setContentText("You have not selected an associated part to delete from the associated parts table.");
            a.show();
        }
        else{
            Alert a = new Alert(Alert.AlertType.CONFIRMATION);
            a.setTitle("Delete Confirmation");
            a.setContentText("Are you sure you want to delete " + selected.getName() + " from the associated parts table?");

            Optional<ButtonType> result = a.showAndWait();
            if (result.isPresent() && (result.get() == ButtonType.OK)) {
                holderAssociatedParts.remove(selected);
                tablePartsProd.getSelectionModel().clearSelection();
                refreshTables();
            }
        }
    }

    /**
     * This method creates a new <code>Product</code> object using the user input and the data in the associated parts table.
     * User input is validated before it is accepted.
     * It then instructs the <code>MainController</code> to either add this product or update an existing product in the list of all products.
     * It then changes the view to the main view and resets the product view to its default state
     *
     * @param event the event thrown when a user clicks the save button
     * @throws Exception NullPointerException when the <code>FXMLLoader</code> can not find the fxml file
     * @throws Exception IOException if FXMLLoader attempts to load a null value
     */
    @FXML
    void onClickSaveProd(ActionEvent event) throws Exception{
        Alert a = new Alert(Alert.AlertType.ERROR);
        
        String userProdName = null;
        double userCPI;
        int userMin;
        int userMax;
        int userStock;


        int userProdId;
        if(!isModify){
            userProdId = nextProductId;
        }
        else {
            userProdId = Integer.parseInt(textProdId.getText());
        }

        try {
            userProdName = textProdName.getText();

            if (userProdName.isEmpty() || !userProdName.matches("[a-zA-Z]+")){
                a.setTitle("Error - Part Name invalid.");
                a.setContentText("A product name can only contain letters and must not be empty");
                a.show();
                return;
            }
        }
        catch(Exception e){
            a.setTitle("Error - Product Name invalid.");
            a.setContentText("You have entered an invalid string value for Product Name.");
            a.show();
            return;
        }

        try{
            userStock = Integer.parseInt(textProdStock.getText());
            if (userStock < 0){
                throw new Exception();
            }
        }
        catch(Exception e) {
            a.setTitle("Error - Stock not a valid positive integer.");
            a.setContentText("You have entered an invalid integer value for Stock.");
            a.show();
            return;
        }

        try {
            userCPI = Double.parseDouble(textProdCPI.getText());
            if (userCPI < 0){
                throw new Exception();
            }
        }
        catch(Exception e){
            a.setTitle("Error - Cost not a valid positive double.");
            a.setContentText("You have entered an invalid double value for Cost.");
            a.show();
            return;
        }

        try{
            userMin = Integer.parseInt(textProdMin.getText());
            if (userMin < 0){
                throw new Exception();
            }
        }
        catch(Exception e){
            a.setTitle("Error - Minimum not a valid positive integer.");
            a.setContentText("You have entered an invalid integer value for Minimum.");
            a.show();
            return;
        }

        try {
            userMax = Integer.parseInt(textProdMax.getText());
            if (userMax < 0){
                throw new Exception();
            }
        }
        catch(Exception e){
            a.setTitle("Error - Maximum not a valid positive integer.");
            a.setContentText("You have entered an invalid integer value for Maximum.");
            a.show();
            return;
        }

        if (!(userMin <= userStock && userStock <= userMax)){
            a.setTitle("Error - Not a valid range");
            a.setContentText("Minimum and Max do not form a valid range or Stock does not fall between minimum and maximum");
            a.show();
            return;
        }
        
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("MainView.fxml"));
        Node node = (Node) event.getSource();
        Stage stage = (Stage) node.getScene().getWindow();
        Scene mainScene = new Scene(fxmlLoader.load(), 1055, 364);

        MainController mainController = fxmlLoader.getController();

        if(!isModify) {
            mainController.addProduct(new Product(holderAssociatedParts, userProdId, userProdName, userCPI, userStock, userMin, userMax));
        }
        else{
            mainController.modifyProduct(modProductIndex, new Product(holderAssociatedParts, userProdId, userProdName, userCPI, userStock, userMin, userMax));
        }

        if(!isModify){
            nextProductId++;
        }

        clearPage();
        stage.setScene(mainScene);
    }

    /**
     * This method searches the parts table for a user input string
     * It can find partial or exact part matches and exact part id matches
     *
     */
    @FXML
    void partSearch() {
        try {
            String findMe = textPartSearchProd.getText();

            if (!findMe.isEmpty() && !findMe.matches("[a-zA-Z0-9]+")) {
                Alert a = new Alert(Alert.AlertType.ERROR);
                a.setTitle("Invalid Search");
                a.setContentText("Search strings should only contain letters and digits");
                a.show();
                return;
            }

            int findId = -1;

            ObservableList<Part> foundParts = FXCollections.observableArrayList();

            if (findMe.isEmpty()) {
                tablePartsProd.getItems().setAll(inventory.getAllParts());
            } else {
                try {
                    findId = Integer.parseInt(findMe);
                } catch (Exception e) {
                }

                if (findId >= 0) {
                    foundParts = inventory.lookupPart(findId);
                    tablePartsProd.getItems().setAll(foundParts);
                    if (foundParts.isEmpty()) {
                        Alert a = new Alert(Alert.AlertType.ERROR);
                        a.setTitle("Error - No Part Found");
                        a.setContentText("No part found for the search string " + findMe);
                        a.show();
                    }
                } else {
                    foundParts = inventory.lookupPart(findMe);
                    tablePartsProd.getItems().setAll(foundParts);
                    if (foundParts.isEmpty()) {
                        Alert a = new Alert(Alert.AlertType.ERROR);
                        a.setTitle("Error - No Product Found");
                        a.setContentText("No product found for the search string " + findMe);
                        a.show();
                    }
                }
            }
        }
        catch(Exception e){
            Alert a = new Alert(Alert.AlertType.ERROR);
            a.setTitle("Error - No Product Found");
            a.setContentText("No product found for the search string ");
            a.show();
            tablePartsProd.getItems().setAll();
        }
    }
}